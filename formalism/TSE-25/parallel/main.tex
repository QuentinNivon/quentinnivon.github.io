
\documentclass{article}
\usepackage[utf8]{inputenc}
%\usepackage{hyperref}
\title{Parallelism Insertion Formalisation}
\author{Quentin Nivon, Gwen Sala{\"u}n}


\usepackage{a4wide}
\usepackage[export]{adjustbox}
\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{algpseudocode}
%\usepackage{alltt}
\usepackage{AMMALanguages}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[toc,page]{appendix}
\usepackage{array} 							    % needed for newcolumntype
%\usepackage[french]{babel}
\usepackage[altpo, epsilon]{backnaur}
\usepackage{booktabs}
\usepackage{cancel}
\usepackage{caption}
\usepackage{comment}
%\usepackage{courier}
\usepackage{enumitem}
\usepackage{epigraph}				 			% Citations en début de chapitre
\usepackage{fancyhdr} 							% en-tete et pied de page, pour plus d'info: texdoc fancyhdr
\usepackage{float}
\usepackage[T1]{fontenc} 						% fontenc permet entre autre de rechercher des mots avec accents dans les PDF produits
\usepackage{footnote}
\usepackage{framed}
%\usepackage{graphicx}
\usepackage{hhline}
\usepackage[nodisplayskipstretch]{setspace}		% pas en ordre alphabétique car doit être importé avant "hyperref" pour que les hyperliens des notes de bas de page fonctionnent correctement
\usepackage[hidelinks]{hyperref}
%\usepackage[latin1]{inputenc}      			% latin1 n'encode pas la ligature oe, utiliser {\oe}
%\usepackage[utf8]{inputenc}
\usepackage{listing}
\usepackage{listings}
\usepackage{lmodern}			    			% une police OK pour l'encodage en T1
\usepackage{makecell}
\usepackage{mathtools}
%\usepackage[a4paper]{meta-donnees} 		    % Pour la page de garde de l'université de Grenoble. (temporarily commented)
\usepackage{minitoc}
%\usepackage{msc} 								% Message Sequence Diagrams
%\usepackage{multicol} 						    % to allow listings on double column
\usepackage{multirow}
%\usepackage{orcidlink}
\usepackage{parskip}          					% paragraphe : pas d'indentation, un saut de ligne
\usepackage{pdflscape}
\usepackage[final]{pdfpages}	    			% to add the pdf pages
\usepackage{pgfplots}
\usepackage{pifont}

\usepackage{soul}
\usepackage[labelformat=simple, belowskip=1ex]{subcaption}
%\usepackage{subfig}             				% plusieurs figures en une
%\usepackage{subfigure}
\usepackage{tablefootnote}
%\usepackage{tabularx}             				% table qui s'étendent sur la largeur de la page
\usepackage{tikz}
\usetikzlibrary{fit} 
\usepackage{tikz-bpmn}
\usepackage{titlesec}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
%\usepackage{txfonts}
\usepackage{url}
%\usepackage{verbatim}
%\usepackage{xspace}

%------------------------------------------------- NEW COMMANDS --------------------------------------------------

\newcommand{\absorbance}[1]{\ensuremath{\mathtt{absorbance}(#1)}}
\newcommand{\acyclicpath}{p_{\cancelledcirclearrow}}
\newcommand{\acyclicisreachablefrom}[2]{#1 \xrightarrow{R_{\cancelledcirclearrow}} #2}
\newcommand{\aetof}[1]{\ensuremath{\mathit{AET}(#1)}}
\newcommand{\algendif}{\text{\textbf{end if}}}
\newcommand{\algif}{\text{\textbf{if }}}
\newcommand{\algobreak}{\text{\textbf{break}}}
\newcommand{\algreturn}{\State \Return}
\newcommand{\algthen}{\text{\textbf{then}}}
%\newcommand{\allchoicesop}[1]{\texttt{allChoices}(#1)}
\newcommand{\allchoicesop}[1]{\ensuremath{\mathcal{C}}(#1)}
%\newcommand{\allcondstructsop}[1]{\texttt{CS}(#1)}
\newcommand{\allcondstructsop}[1]{\ensuremath{\mathcal{S}(#1)}}
%\newcommand{\allgraphsop}[1]{\texttt{allGraphs}(#1)}
\newcommand{\allgraphsop}[1]{\ensuremath{\mathcal{G}}(#1)}
%\newcommand{\alllabelsop}[1]{\texttt{allLabels}(#1)}
\newcommand{\alllabelsop}[1]{\ensuremath{\Sigma}(#1)}
%\newcommand{\allloopsop}[1]{\texttt{allLoops}(#1)}
\newcommand{\allloopsop}[1]{\ensuremath{\mathcal{L}}(#1)}
%\newcommand{\allnodesop}[1]{\texttt{allNodes}(#1)}
\newcommand{\allnodesop}[1]{\ensuremath{\mathcal{V}}(#1)}
\newcommand{\allstructsop}[1]{\texttt{allStructs}(#1)}
%\newcommand{\alltasksop}[1]{\texttt{allTasks}(#1)}
\newcommand{\alltasksop}[1]{\ensuremath{\mathcal{T}}(#1)}
\newcommand{\anyof}[2]{\ensuremath{\mathtt{any}(#1, #2)}}
\newcommand{\anyofproba}[2]{\ensuremath{\mathtt{any}_p(#1, #2)}}
\newcommand{\anyofprobaunique}[1]{\ensuremath{\mathtt{any}_p(#1)}}
\newcommand{\anyofunique}[1]{\ensuremath{\mathtt{any}(#1)}}
\newcommand{\bnfterm}[1]{$\langle$#1$\rangle$}
%\newcommand{\boundary}[1]{\texttt{boundary}(#1)}
\newcommand{\boundary}[1]{\ensuremath{\partial(#1)}}
\newcommand{\bpmnacyclicpaths}[1]{\mathcal{\widehat{P}}_{#1}^{0}}
\newcommand{\bpmnacyclicpathsof}[2]{\mathcal{\widehat{P}}_{#1}^{0}(#2)}
\newcommand*{\bpmnendevent}{\tikz[baseline=-.25em]{\node[circle, draw, ultra thick, minimum width=1.2em, minimum height=1.2em] () {e};}}
\newcommand*{\bpmnorgw}{\tikz[baseline=-.25em]{\node[shape=ID,draw,inner sep=0pt, minimum size=1.5em]  (X) {};}}
\newcommand*{\bpmnpargw}{\tikz[baseline=-.25em]{\node[shape=PF,draw,inner sep=0pt, minimum size=1.5em] (X) {};}}
\newcommand{\bpmnpargwmerge}{\ensuremath{\bpmnpargw_M}}
\newcommand{\bpmnpargwmergetype}{\bpmnpargwmerge}
\newcommand{\bpmnpargwsplit}{\ensuremath{\bpmnpargw_S}}
\newcommand{\bpmnpargwsplittype}{\bpmnpargwsplit}
\newcommand{\bpmnpaths}[1]{\mathcal{P}_{#1}^{0}}
\newcommand{\bpmnpathsof}[2]{\mathcal{P}_{#1}^{0}(#2)}
\newcommand*{\bpmnstartevent}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {s};}}
\newcommand{\bpmntask}[1]{\tikz[baseline=-.25em]{\node[rectangle, draw, black, minimum width=2em, minimum height=1.5em, rounded corners] () {#1};}}
\newcommand{\bpmnredtask}[1]{\tikz[baseline=-.25em]{\node[rectangle, draw, red, minimum width=2em, minimum height=1.5em, rounded corners] () {\textcolor{red}{#1}};}}
\newcommand*{\bpmnxorgw}{\tikz[baseline=-.25em]{\node[shape=XOR,draw,inner sep=0pt, minimum size=1.5em] (X) {};}}
\newcommand{\bpmnxorgwmerge}{\ensuremath{\bpmnxorgw_M}}
\newcommand{\bpmnxorgwmergetype}{\bpmnxorgwmerge}
\newcommand{\bpmnxorgwsplit}{\ensuremath{\bpmnxorgw_S}}
\newcommand{\bpmnxorgwsplittype}{\bpmnxorgwsplit}
\newcommand{\cancelledcirclearrow}{\rotatebox[origin=c]{180}{\ensuremath{\cancel{\circlearrowright}}}}
\newcommand{\cardof}[1]{\lvert #1 \rvert}
\newcommand{\childrenof}[1]{\ensuremath{\mathtt{child}(#1)}}
%\newcommand{\childrenof}[1]{\mathit{children(#1)}}
%\newcommand{\childrenof}[1]{\mathit{#1.children}}
\newcommand{\choiceop}{`$\vert$' }
\newcommand{\choiceopw}{`$\vert$'}
\newcommand{\closedarray}[2]{[#1...#2]}
\newcommand{\closestboundary}[2]{\ensuremath{\mathtt{boundary}^*(#1, #2)}}
%\newcommand{\closestcondstruct}[1]{\ensuremath{\mathtt{CCS}(#1)}}
\newcommand{\closestcondstruct}[1]{\ensuremath{\mathcal{S}^*(#1)}}
%\newcommand{\closestnode}[1]{\ensuremath{\mathtt{CN}(#1)}}
\newcommand{\closestnode}[1]{\ensuremath{\mathcal{V}^*(#1)}}
%\newcommand{\closestseqgraph}[1]{\ensuremath{\mathtt{CSG}(#1)}}
\newcommand{\closestseqgraph}[1]{\ensuremath{\mathcal{G}^*(#1)}}
\newcommand{\cluster}[1]{\ensuremath\textit{cluster}(#1)}
\newcommand{\code}[1]{\textsf{\small #1}}
\newcommand{\comaop}{`$,$' }
\newcommand{\comaopw}{`$,$'}
%\newcommand{\confset}[1]{\texttt{Hist}(#1)}
\newcommand{\confset}[1]{\history(#1)}
\newcommand{\constraints}{\mathit{Cons}}
\newcommand{\context}[2]{\ensuremath\textit{context}(#1,#2)}
\newcommand{\contextAux}[3]{\ensuremath\textit{context}(#1,#2,#3)}
%\newcommand{\contextwisemutex}{\vert_{CW}}
\newcommand{\contextwisemutex}[2]{\ensuremath{#1\ \vert_{CW}\ #2}}
\newcommand{\continue}{\text{\textbf{continue}}}
%\newcommand{\costop}[1]{\texttt{cost}(#1)}
\newcommand{\costop}[1]{\ensuremath{\mathtt{cost}(#1)}}
\newcommand{\csg}[2]{\ensuremath\textit{csg}(#1,#2)}
\newcommand{\cyclicpath}{p_{\mycirclearrow}}
\newcommand{\cyclicisreachablefrom}[2]{#1 \xrightarrow{R_{\mycirclearrow}} #2}
%\newcommand{\defequals}{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\newcommand{\defequals}{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}
\newcommand{\degreeof}[1]{\ensuremath{\mathtt{deg}(#1)}}
\newcommand{\dependencies}{\ensuremath{\mathtt{Dep}}}
\newcommand{\distanceof}[2]{\ensuremath{\|(#1,#2)\|}}
%\newcommand{\durationop}[1]{\ensuremath{\mathtt{duration}(#1)}}
\newcommand{\durationop}[1]{\ensuremath{\delta(#1)}}
\newcommand{\example}{\textit{Example. }}
\newcommand{\expressionsset}{\ensuremath{\mathtt{Expr}}}
\newcommand{\fourspaces}{\space \space \space \space}
\newcommand{\genop}[2]{\ensuremath{\mathtt{gen}(#1,#2)}}
\newcommand{\geniop}[3]{\ensuremath{\mathtt{gen}_{P_{#1}\!}(#2,#3)}}
\newcommand{\geniiop}[4]{\ensuremath{\mathtt{gen}_{P_{#1}\!}^{#2}(#3,#4)}}
\newcommand{\GFL}{\ensuremath G_\textit{FL}}
\newcommand{\GLF}{\ensuremath G_\textit{LF}}
\newcommand{\GlobalTimer}{\ensuremath{\mathfrak{T}}}
\newcommand{\GlobalTimerOf}[1]{\ensuremath{\mathfrak{T}(#1)}}
\newcommand{\graph}{G~=~(V,~E,~\Sigma)}
\newcommand{\graphparam}[1]{G_{#1}=(V_{#1},E_{#1},\Sigma_{#1})}
%\newcommand{\graph}{G~=~(V,~E,~\Sigma,~I)}
\newcommand{\greaterentirepart}[1]{\ensuremath{\lceil #1 \rceil}}
%\newcommand{\holdtoken}[1]{\dot{#1}}
\newcommand{\history}{\ensuremath{\mathcal{H}}}
\newcommand{\holdtoken}[1]{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily $\bullet$}}}{#1}}}
\newcommand{\iat}{\ensuremath{\mathit{IAT}}}
\newcommand{\indexof}[1]{\mathtt{index}(#1)}
\newcommand{\infreach}{$\infty$-reachability}
\newcommand{\initialeventtype}{\texttt{initial event}}
\newcommand{\insertop}{\ensuremath{\mathtt{ins}}}
\newcommand{\isreachablefrom}[2]{#1 \xrightarrow{R} #2}
\newcommand{\labelof}[1]{\sigma(#1)}
\newcommand{\lclosedarray}[2]{[#1...#2[}
\newcommand{\loopmandaop}{`$+$' }
\newcommand{\loopop}{`$*$' }
\newcommand{\loopoptioop}{`$?$' }
\newcommand{\loopopw}{`$*$'}
\newcommand{\loops}{\ensuremath{\mathtt{Loops}}}
\newcommand{\lowerentirepart}[1]{\ensuremath{\lfloor #1 \rfloor}}
\newcommand{\lslice}[2]{#1[#2:]}
\newcommand{\ltland}{\ensuremath{\land}}
\newcommand{\ltlF}{\textbf{F}}
\newcommand{\ltlG}{\textbf{G}}
\newcommand{\ltlimplies}{\ensuremath{\Rightarrow}}
\newcommand{\ltlN}{\textbf{N}}
\newcommand{\ltlnot}{\ensuremath{\lnot}}
\newcommand{\ltlor}{\ensuremath{\lor}}
\newcommand{\ltlU}{\textbf{U}}
\newcommand{\ltlW}{\textbf{W}}
\newcommand{\maxnbinstances}{\ensuremath{I_{\mathit{max}}}}
\newcommand{\move}[2]{\ensuremath\textit{move}(#1,#2)}
\newcommand{\moveup}{$\mu$ }
\newcommand{\moveuprec}{$\mu_r$ }
\newcommand{\mutex}[2]{\ensuremath{#1\ \vert\ #2}}
%\newcommand{\mutex}{\vert}
\newcommand{\mutexesof}[1]{\ensuremath{\mathtt{mutex}(#1)}}
\newcommand{\mycirclearrow}{\rotatebox[origin=c]{180}{\ensuremath{\circlearrowright}}}
\newcommand{\mycmark}{\ding{51}}%
\newcommand{\myendeventtype}{\texttt{end event}}
\newcommand{\mysubitem}[2]{{\setlength\itemindent{15pt} \item[#1] #2}}
\newcommand{\myxmark}{\ding{55}}%
\newcommand{\namedgraph}[1]{#1~=~(V,~E,~\Sigma,~I)}
\newcommand{\naturals}{\ensuremath{\mathbb{N}}}
\newcommand{\newtask}[1]{\textit{#1}}
\newcommand{\normal}[2]{\ensuremath{\mathcal{N}(#1, #2)}}
\newcommand{\normalise}[1]{\ensuremath{\mathtt{norm}(#1)}}
\newcommand{\normalisei}[1]{\ensuremath{\mathtt{norm}_i(#1)}}
\newcommand{\normaliseone}[1]{\ensuremath{\mathtt{norm}_1(#1)}}
\newcommand{\normalisetwo}[1]{\ensuremath{\mathtt{norm}_2(#1)}}
\newcommand{\normalisethree}[1]{\ensuremath{\mathtt{norm}_3(#1)}}
\newcommand{\openarray}[2]{]#1...#2[}
\newcommand{\parallelsof}[1]{\ensuremath{\mathtt{par}(#1)}}
\newcommand{\paramedconstraints}[1]{\mathit{Cons_{#1}}}
\newcommand{\paramedgraph}[1]{G_{#1}~=~(V_{#1},~E_{#1},~\Sigma_{#1},~I_{#1})}
%\newcommand{\parentof}[1]{\texttt{parent}(#1)}
\newcommand{\parentof}[1]{\ensuremath{\mathtt{parent}(#1)}}
%\newcommand{\parentsof}[1]{\mathit{#1.parents}}
\newcommand{\parentsof}[1]{\ensuremath{\mathtt{parents}(#1)}}
\newcommand{\parop}{`$\&$' }
\newcommand{\paropw}{`$\&$'}
\newcommand{\paths}[1]{\mathcal{P}_{#1}}
\newcommand{\pathsof}[2]{\mathcal{P}_{#1}(#2)}
\newcommand{\pLF}{\ensuremath p_\textit{LF}}
\newcommand{\predecessorsof}[1]{\ensuremath{\mathtt{pred}(#1)}}
%\newcommand{\predecessorsof}[1]{\mathit{#1.predecessors}}
%\newcommand{\pushtokens}[1]{\texttt{push}(#1)}
\newcommand{\pushtokens}[1]{\ensuremath{\mathtt{push}(#1)}}
\newcommand{\rclosedarray}[2]{]#1...#2]}
\newcommand{\redtext}[1]{\textcolor{red}{#1}}
\newcommand{\redbold}[1]{\textcolor{red}{\ensuremath{\mathbf{#1}}}}
\newcommand{\reduceop}[1]{\texttt{reduce}(#1)}
\newcommand{\Rho}{\ensuremath{P}}
\newcommand{\remove}[2]{\ensuremath\textit{remove}(#1,#2)}
%\newcommand{\removealltasksop}[2]{\texttt{remove}^*(#1, #2)}
\newcommand{\removealltasksop}[2]{\ensuremath{\mathtt{rem}^*(#1, #2)}}
\newcommand{\removestar}[2]{\ensuremath\textit{rem}^*(#1,#2)}
\newcommand{\removetaskop}[2]{\ensuremath{\mathtt{rem}(#1, #2)}}
\newcommand{\resname}[1]{\textsf{#1}}
\newcommand{\resource}[1]{\textsf{#1}}
\newcommand{\resourcesop}[2]{\ensuremath{\rho(#1, #2)}}
\newcommand{\respool}{\ensuremath{\Rho}}
\newcommand{\respoolinfty}{\ensuremath{\Rho_\infty}}
\newcommand{\restrictionof}[2]{\ensuremath{#1\restriction_{#2}}}
\newcommand{\rexample}{\textit{Running example. }}
\newcommand{\rootof}[1]{\ensuremath{\mathtt{root}(#1)}}
\newcommand{\rslice}[2]{#1[:#2]}
\newcommand{\sandgwmerge}{\andgw$_M$ }
\newcommand{\sandgwsplit}{\andgw$_S$ }
%\newcommand{\scoreop}[1]{\texttt{score}(#1)}
\newcommand{\scoreop}[1]{\ensuremath{\mathtt{score}(#1)}}
\newcommand{\sendtoken}[2]{#1 \xrightarrow{\token} #2}
\newcommand{\seqgraph}{\ensuremath{G_< = (\seqgraphnodes, \seqgraphedges, \seqgraphlabels)}}
\newcommand{\seqgraphchoice}{\ensuremath{\bpmnxorgw_C}}
%\newcommand{\seqgraphchoicetype}{\seqgraphchoice}
\newcommand{\seqgraphchoicetype}{\ensuremath{\mathcal{C}}}
\newcommand{\seqgraphedge}{\ensuremath{e_<}}
\newcommand{\seqgraphedges}{\ensuremath{E_<}}
\newcommand{\seqgraphfirstnode}[1]{\ensuremath{\mathtt{first}(#1)}}
%\newcommand{\seqgraphgraphtype}{G}
\newcommand{\seqgraphgraphtype}{\ensuremath{\mathcal{G}}}
\newcommand{\seqgraphlastnode}[1]{\ensuremath{\mathtt{last}(#1)}}
\newcommand{\seqgraphloop}{\ensuremath{\bpmnxorgw_L}}
%\newcommand{\seqgraphlooptype}{\seqgraphloop}
\newcommand{\seqgraphlooptype}{\ensuremath{\mathcal{L}}}
\newcommand{\seqgraphlabels}{\ensuremath{\Sigma_<}}
\newcommand{\seqgraphnode}{\ensuremath{v_<}}
\newcommand{\seqgraphnodes}{\ensuremath{V_<}}
\newcommand{\seqgraphparent}[1]{\ensuremath{\mathtt{parent}}(#1)}
\newcommand{\seqgraphpred}[1]{\ensuremath{\mathtt{pred}(#1)}}
\newcommand{\seqgraphsucc}[1]{\ensuremath{\mathtt{succ}(#1)}}
\newcommand{\seqgraphtasktype}{\ensuremath{\mathcal{T}}}
\newcommand{\seqop}{`$<$' }
\newcommand{\seqopw}{`$<$'}
\newcommand{\sledom}{\Relbar\joinrel\mathrel{|}}
\newcommand{\slice}[3]{#1[#2:#3]}
\newcommand{\SosSpace}{\ \ \ \ \ }
\newcommand{\specialcell}[2][c]{%
	\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}
}
%\newcommand{\strongmutex}{\vert_S}
\newcommand{\strongmutex}[2]{\ensuremath{#1\ \vert_S\ #2}}
\newcommand{\successorsof}[1]{\ensuremath{\mathtt{succ}(#1)}}
%\newcommand{\successorsof}[1]{\mathit{#1.successors}}
\newcommand{\swcetop}[2]{\texttt{SWCET}(#1, #2)}
\newcommand{\swcetopinf}[1]{\ensuremath{\texttt{SWCET}(#1, \Rho_{\infty})}}
\newcommand{\sxorgwmerge}{\xorgw$_M$ }
\newcommand{\sxorgwsplit}{\xorgw$_S$ }
\newcommand{\sync}[1]{\mathtt{sync}(#1)}
\newcommand{\task}[1]{\textsf{#1}}
\newcommand{\taskname}[1]{\textsf{#1}}
%\newcommand{\tasksop}[1]{\texttt{tasks}(#1)}
\newcommand{\tasksop}[1]{\ensuremath{\mathtt{tasks}(#1)}}
\newcommand{\tasktype}{\texttt{task}}
\newcommand{\token}{\bullet}
\newcommand{\transition}[2]{#1~\rightarrow~#2}
\newcommand{\treeanytype}[1]{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {#1};}}
\newcommand{\treechoicetype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {\ensuremath{\vert}};}}
\newcommand{\treecomatype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.5em, minimum height=1.5em] () {,};}}
\newcommand{\treelooptype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {*};}}
\newcommand{\treenode}[1]{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1em, minimum height=1em] () {\ensuremath{#1}};}}
\newcommand{\treeop}[1]{\ensuremath{T_{\preceq}(#1)}}
\newcommand{\treepartype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {\&};}}
\newcommand{\treeseqtype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {<};}}
\newcommand{\treetasktype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {t};}}
\newcommand{\tupleof}[2]{(#1, ..., #2)}
%\newcommand{\typeof}[1]{\texttt{type}(#1)}
\newcommand{\typeof}[1]{\ensuremath{\theta(#1)}}
\newcommand{\uniform}[2]{\ensuremath{\mathcal{U}_{[#1, #2]}}}
\newcommand{\WaitingTasksOP}[2]{\texttt{wait}(#1, #2)}
\newcommand{\wcetop}[2]{\texttt{WCET}(#1, #2)}
\newcommand{\wcetopinf}[1]{\texttt{WCET}(#1, \ensuremath{R_\infty})}
%\newcommand{\weakmutex}{\vert_W}
\newcommand{\weakmutex}[2]{\ensuremath{#1\ \vert_W\ #2}}

%------------------------------------------------- RENEW COMMANDS --------------------------------------------------

\renewcommand\thesubfigure{(\alph{subfigure})}

%------------------------------------------------- DECLARE MATH OPERATOR -------------------------------------------

\DeclareMathOperator{\anc}{anc}
\DeclareMathOperator{\des}{des}
\DeclareMathOperator{\find}{find}
\DeclareMathOperator{\lca}{LCA}
\DeclareMathOperator{\none}{None}
\DeclareMathOperator{\pred}{pred}
\DeclareMathOperator{\merge}{merge}
\DeclareMathOperator{\reduce}{reduce}
\DeclareMathOperator{\riu}{riu}
\DeclareMathOperator{\size}{size}
\DeclareMathOperator{\smallpred}{p}
\DeclareMathOperator{\suc}{succ}
\DeclareMathOperator{\swap}{swap}
\DeclareMathOperator{\troot}{root}
\DeclareMathOperator{\typ}{type}
\DeclareMathOperator{\type}{type}

%------------------------------------------------------ NEW THEOREM ------------------------------------------------

\newtheorem{definition}{Definition}
%\newtheorem{proof}{Proof}				% commenter si problème de compilation sur linux/décommenter si problème de compilation sur windows
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}

%--------------------------------------------------------- DIVERS --------------------------------------------------

\pagestyle{fancy}
\pgfplotsset{width=7cm,compat=1.18}
%\setlength{\levelheight}{0.9\levelheight}





%\lstset{
	%numbers=left,
	%numberstyle=\tiny,
	%language={Java},
	%mathescape=true,
	%flexiblecolumns=true,
	%morekeywords={def,Int,call,method,var,assert,share,unshare,acquire,release,fork,join,free,invariant,requires,ensures,acc,rd,old},
	%basicstyle=\sffamily\small,
	%moredelim=[is][\itshape]{@}{@},
	%stepnumber=1,
	%numbersep=2pt} 

%\input{cadp-mcl.sty}

\lstdefinelanguage{LOTOS}
{
	morekeywords=[1]{accept,actualizedby,any,behaviour,behavior,choice,
		endlib,endproc,endspec,endtype,eqns,exit,
		for,forall,formaleqns,formalopns,formalsorts,hide,
		i,in,is,let,library,noexit,
		of,ofsort,opnnames,opns,par,process,
		renamedby,sortnames,sorts,specification,stop,type,
		using,where},
	morekeywords=[2]{atomic,comparedby,constructor,enumeratedby,external,implementedby,
		iteratedby,printedby},
	morekeywords=[3]{BasicNaturalNumber,Bit,BitNatRepr,BitString,Bool,Boolean,
		DecDigit,DecNatRepr,DecString,HexDigit,HexNatRepr,HexString,
		NatRepresentations,Nat,NaturalNumber,OctDigit,Octet,OctetString,
		OctNatRepr,OctString,Set,String},
	morekeywords=[4]{false,true},
	morekeywords=[5]{and,Bit1,Bit2,Bit3,Bit4,Bit5,
		Bit6,Bit7,Bit8,Card,eq,ge,
		gt,iff,implies,Includes,Insert,Ints,
		IsIn,IsSubsetOf,le,Length,lt,Minus,
		NatNum,ne,not,NotIn,or,Remove,
		Reverse,Succ,Union,xor},
	otherkeywords={<,>,+,-,/,!,
		?,;,**,==,<>,<=,
		>=,=>,>>,[>,||,|[,
		]|,[],|||},
	sensitive=false,
	morecomment=[s]{(*}{*)}
}[keywords,comments]


%% Listings definitions for the LOTOS language
%% produced by Syntax Editor Configuration Tool <cadp@inria.fr>
%% version 1.7:LOTOS+1.7:SECT

\lstdefinelanguage{LOTOS}
{
	morekeywords=[1]{accept,actualizedby,any,behaviour,behavior,choice,
		endlib,endproc,endspec,endtype,eqns,exit,
		for,forall,formaleqns,formalopns,formalsorts,hide,
		i,in,is,let,library,noexit,
		of,ofsort,opnnames,opns,par,process,
		renamedby,sortnames,sorts,specification,stop,type,
		using,where},
	morekeywords=[2]{atomic,comparedby,constructor,enumeratedby,external,implementedby,
		iteratedby,printedby},
	morekeywords=[3]{BasicNaturalNumber,Bit,BitNatRepr,BitString,Bool,Boolean,
		DecDigit,DecNatRepr,DecString,HexDigit,HexNatRepr,HexString,
		NatRepresentations,Nat,NaturalNumber,OctDigit,Octet,OctetString,
		OctNatRepr,OctString,Set,String},
	morekeywords=[4]{false,true},
	morekeywords=[5]{and,Bit1,Bit2,Bit3,Bit4,Bit5,
		Bit6,Bit7,Bit8,Card,eq,ge,
		gt,iff,implies,Includes,Insert,Ints,
		IsIn,IsSubsetOf,le,Length,lt,Minus,
		NatNum,ne,not,NotIn,or,Remove,
		Reverse,Succ,Union,xor},
	otherkeywords={<,>,+,-,/,!,
		?,;,**,==,<>,<=,
		>=,=>,>>,[>,||,|[,
		]|,[],|||},
	sensitive=false,
	morecomment=[s]{(*}{*)}
}[keywords,comments]


%%%%%%%%%%%%%%
%%% Thesis Hugues
%%%%%%%%%%%%%%%%

% ------------------------------ LNT listings ------------------------------

\lstdefinelanguage{LNT}
{morekeywords={
		any, as, break, by, case, comparedby, do, else, elsif, end, eval,
		external, for, function, hide, if, implementedby, in, inout, is,
		list, loop, module, null, of, only, out, par, printedby, process,
		raise, raises, return, select, set, sorted, stop, then, type, var,
		where, while, with, array, channel, disrupt, iteratedby,
		representedby,
		!nat_bits,!nat_inf,!nat_sup,!nat_check,!int_bits,!int_inf,
		!int_sup,!int_check,!string_card,!comparedby,!external,!implementedby,
		!iteratedby,!printedby,!representedby
	},
	otherkeywords={?,|,\#,->,[],||},
	alsoletter={!},
	sensitive=false,
	morecomment=[l]{--},
	morecomment=[s]{(*}{*)},
	morestring=[b]"
}

\lstdefinelanguage{SVL}
{
	morekeywords=[1]{abstraction,all,bag,branching,but,chaos,
		check,comparison,cut,deadlock,divbranching,end,
		expected,fifo,gate,generation,hide,in,
		is,label,labels,leaf,livelock,multiple,
		node,observational,of,par,partial,prio,
		probabilistic,property,reduction,refined,rename,result,
		root,safety,single,smart,stochastic,stop,
		strong,sync,tau-compression,tau-confluence,tau-divergence,tau*.a,
		total,trace,user,using,verify,weak,
		with},
	morekeywords=[2]{\%},
	morekeywords=[3]{acyclic,bdd,bfs,dfs,fly,std},
	morekeywords=[4]{FALSE,TRUE},
	morekeywords=[5]{aldebaran,bcg_min,bcg_cmp,bisimulator,evaluator,evaluator3,
		evaluator4,exhibitor,fc2tools,reductor,xtl},
	% otherkeywords={%
		%                  :,\#,?,==,>=,<=,
		%                  |=,->,||
		%                  %,|[,]|,-||,
		%                  %-|[,|||,-|||
		%                },
	alsoletter={-*.\%},
	sensitive=true,
	morecomment=[l]{--},
	morecomment=[s]{(*}{*)},
	morestring=[b]{'},
	morestring=[b]{"}
}[keywords,comments,strings]

\lstdefinelanguage{MCL}
{
	morekeywords=[1]{among,any,case,choice,continue,do,
		else,elsif,end,end_library,end_macro,exists,
		exit,export,for,forall,from,if,
		in,let,library,loop,macro,mu,
		nil,nu,of,on,repeat,step,
		tau,then,to,until,where,while},
	morekeywords=[2]{bool,nat,natset,int,real,char,
		string},
	morekeywords=[3]{false,true},
	morekeywords=[4]{abs,and,concat,diff,empty,equ,
		implies,index,insert,isin,isalnum,isalpha,
		isdigit,islower,isupper,isxdigit,inter,length,
		not,nth,or,prefix,remove,rindex,
		sign,substr,succ,suffix,tolower,toupper,
		union,xor},
	otherkeywords={
		%+,-,=,/,
		!,^,
		\%,|,<,>,[,],
		@,
		%*,
		?,<>,<=,>=,
		->,-|
	},
	sensitive=false,
	morecomment=[s]{(*}{*)},
	morestring=[b]{'},
	morestring=[b]{"}
}[keywords,comments,strings]

% option générale pour tous les langages
\lstset{
	%  basicstyle=\sffamily\scriptsize,
	basicstyle=\sffamily\footnotesize,
	%basewidth=0.55em,% test for sffamily
	columns=flexible,
	showstringspaces=false,
	language=LNT
}

\lstnewenvironment{lnt}
{\lstset{language=LNT}}
{}

\lstnewenvironment{margelnt}
{\lstset{language=LNT,xleftmargin=8mm}}
{}

\lstnewenvironment{margec}
{\lstset{
		language=C,
		basicstyle=\ttfamily\footnotesize,
		%columns=fixed, % pas joli...
		xleftmargin=8mm
}}
{}

\lstnewenvironment{margesh}
{\lstset{
		language=sh,
		basicstyle=\ttfamily\footnotesize,
		xleftmargin=8mm
}}
{}

\lstnewenvironment{margemcl}
{\lstset{language=MCL,stringstyle=\ttfamily,xleftmargin=8mm}}
{}

\lstnewenvironment{margesvl}
{\lstset{language=SVL,stringstyle=\ttfamily,xleftmargin=8mm}}
{}


\MakeRobust\Call

\begin{document}
	\maketitle
	
	At this stage of the BPMN process generation, two operators of the language are still to be managed: the \comaop and the \parop operators.
	The \comaop operator separates tasks that are not constrained to each others, while the \parop operator separates tasks that should be put in parallel.
	However, in BPMN, parallelism precisely describes the absence of constraints between elements, as two parallel elements may end up executing sequentially in any order, or at the same time.
	Thus, we decided to manage the \comaop and the \parop operators the same way.
	
	In this approach, adding parallelism to the graph consists in replacing the exclusive split (resp. merge) gateways by parallel split (resp. merge) gateways.
	However, replacing an exclusive gateway by a parallel gateway may lead to potentially severe issues if not done carefully.
	In BPMN, parallelism can induce two major issues: \textit{deadlocks} and \textit{livelocks}.
	A deadlock occurs whenever a parallel merge gateway does not (and will not) receive a sufficient number of tokens to be triggered, that is, one token per incoming flow.
	This phenomenon prevents the gateway from merging its incoming tokens, and thus from sending a token to its outgoing flow.
	Consequently, the process cannot complete its execution.
	A livelock occurs whenever a parallel split gateway can be reached infinitely often by a token that it sent and which was not merged with its siblings before reaching this parallel split again.
	This parallel split thus produces new tokens infinitely often, thus preventing the process from terminating.
	Such behaviour happens when there is no node \textit{synchronising all the paths} starting from the children of a parallel split gateway that can reach itself.
	
	\begin{comment}
		Indeed, parallelism often comes with its share of problems, and this is also the case in this work.
		By switching an exclusive split gateway to a parallel split gateway, one may easily introduce \textit{deadlocks} or \textit{infinite recursion} in the model.
		A deadlock is a state in which a system (here, the process) can no longer progress due to the waiting of one or several of its parts for the termination of other parts that are themselves waiting for the first ones to terminate.
		In this approach, they may be generated by merge parallel gateways that do not (and will not) receive all the tokens that they need to be activated, thus preventing the children of these gateways from being triggered.
		
		\begin{definition}[Deadlock]
			Let $\graph$ be a graph representing a BPMN process, and let $v \in V$ be a parallel merge gateway \andgw$_M$.
			Following the definition of a parallel merge gateway (Definition~\ref{def:par_merge}), a deadlock occurs whenever $\exists v_p \in \parentsof{v}$ such that $v_p$ does not eventually acquire a token.
			Such a situation prevents \bpmnpargwmerge from being activated, and consequently the process to terminate.
		\end{definition}
		
		The second issue, namely the infinite recursion, is a phenomenon happening whenever a (sub-)process can recursively call itself infinitely.
		In BPMN, it happens when a parallel split gateway can be reached infinitely often by a token that it sent and which was not merged with its siblings beforehand.
		This is the case when a parallel split gateway can reach itself without reaching a node that \textit{synchronises} all its children paths beforehand.
	\end{comment}
	
	%%%%\vspace{-0.1cm}
	\begin{definition}[Paths Synchronisation Node]
		Let $\graph$ be a BPMN process, and $\paths{G}$ be its corresponding set of paths.
		A node $v \in V$ is said to \textnormal{synchronise a set of paths} $\paths{G}' \subseteq \paths{G}$ if and only if $\forall p \in \paths{G}'$, $v \in p$.
		$\paths{G}'$ may have several synchronisation nodes, which can be computed using the $\sync{\paths{G}'}$ operator:
		\begin{equation*}
			\sync{\paths{G}'} =
			\begin{cases}
				v_1,\ ...,\ v_n & \text{if} \ \forall i \in \closedarray{1}{n},\ \forall p \in \paths{G}', \ v_i \in p	\\
				\bot & \text{otherwise}
			\end{cases}
		\end{equation*}
	\end{definition}
	
	%\pagebreak
	
	\begin{definition}[(Syntactic) Livelock]\label{def:infinite_recursion}
		Let $\graph$ be a BPMN process, and let $v \in V$ be a parallel split gateway.
		$G$ contains a \textnormal{(syntactic) livelock} if:
		
		\begin{itemize}
			\setlength\itemsep{-0.4em}
			\item[---] $\exists v_c \in \childrenof{v}$ such that $\isreachablefrom{v_c}{v}$ ($v_c$ can reach $v$);
			\item[---] $\nexists v_s \in V$ such that:
			\begin{itemize}
				\setlength\itemsep{-0.4em}
				\item $v_s \in \sync{\bigcup\limits_{v_c \in \childrenof{v}} \pathsof{G}{v_c}}$;
				\item $\forall p = (v_1, ..., v_s, ..., v_n) \in \bigcup\limits_{v_c \in \childrenof{v}} \pathsof{G}{v_c},\ \exists i \in \closedarray{1}{n}\ \vert\ v_i = v \Rightarrow \indexof{v_s} < i$.
			\end{itemize}
		\end{itemize}
		
		(either the paths starting from children of $v$ are not synchronised, or at least one of them can reach $v$ before reaching $v_s$)
	\end{definition}
	
	\example Figure~\ref{fig:infinite_recursion} illustrates this potential issue on a simple BPMN process.
	As the reader can see, the parallel split gateway sends a token $\tau_1$ to $B$, which reaches the end event, and another token $\tau_2$ to $A$.
	These two tokens are never merged, and $\tau_2$ eventually reaches the parallel split gateway.
	When it receives $\tau_2$, it sends $\tau_1'$ to $B$, and $\tau_2'$ to $A$.
	As the parallel split gateway is triggered infinitely often, there is no way for this process to eventually complete its execution, as it has no possibility to prevent itself from producing new tokens.
	Thus, this process is infinitely recursive.

	
	\subsection{Insertion of the Parallel Gateways}
	
	As mentioned earlier, inserting parallel gateways to the graph mostly consists in replacing some exclusive gateways by parallel ones while avoiding syntactic livelocks.
	However, simply switching the type of a gateway is often not sufficient to handle properly all the possible forms that the process could take.
	Indeed, a simple exclusive split gateway with $n$ children tasks could generate almost $2 \times (2^n - 1)$ syntactically different BPMN constructs.
	
	\example Let us consider the four mutual exclusion constraints \mutex{A}{B}, \mutex{A}{C}, \mutex{A}{D}, and \mutex{C}{D}.
	Before starting to insert parallelism in it, the BPMN subprocess corresponding to these four constraints would be the one shown in Figure~\ref{fig:before_combination}.
	However, if one wants to parallelise the tasks that can be parallelised without breaking any of the four aforementioned mutual exclusions, while adding as much parallelism as he can, he would build the BPMN sub-process displayed in Figure~\ref{fig:after_combination}.
	It is as parallelised as possible, as the only non-parallel tasks are the ones that should be mutually exclusive.
	For instance, according to the constraints, tasks $B$ and $C$ are not mutually exclusive, although they are in Figure~\ref{fig:before_combination}.
	However, after the insertion of parallel gateways, they end up in parallel, as they should be.

	
	\subsubsection{Inserting Parallel Splits}
	
	The generation of parallel structures, such as the one presented above, relies on combinatorics to build all the possible such structures given a set of tasks.
	This is ensured by a function $\eta : V^n \rightarrow W$, assuming that $W$ is the set of all existing workflows.
	Function $\eta$ is recursively defined and its return value is, for clarity, written in the form of expressions compliant with the language defined in Section~\ref{sub:language}.
	
	\begin{definition}[Generation of Parallel Split Structures]
		Let $\graph$ be a BPMN process, and let $g \in V$ be an exclusive split gateway having $n$ children tasks $(t_1, ..., t_n) \in V$ whose parallel structures have to be generated.
		Function $\eta$ is defined as:
		\begin{equation*}
			\eta(\{t_1, ..., t_n\}) =
			\begin{cases}
				\bot \ \ \ \ \ \textnormal{if}\ \cardof{\{t_1, ..., t_n\}} = 0  &	\\
				t_1 \ \ \ \ \ \textnormal{if}\ \cardof{\{t_1, ..., t_n\}} = 1	& 	\\
				\{\eta(\widehat{\{t_1, ..., t_n\}})\ \vert\ \eta(\overline{\{t_1, ..., t_n\}})\} \cup \{\eta(\widehat{\{t_1, ..., t_n\}})\ \&\ \eta(\overline{\{t_1, ..., t_n\}})\} & \textnormal{o/w}	 		
			\end{cases}
		\end{equation*}
		where $\widehat{\{t_1, ..., t_n\}} = \anyof{2_{1^+}^{\{t_1, ..., t_n\}}}{1}$ and $\overline{\{t_1, ..., t_n\}} = \{t_1, ..., t_n\} \setminus \widehat{\{t_1, ..., t_n\}}$.
	\end{definition}
	
	\example Given 3 tasks \textit{A}, \textit{B}, and \textit{C}, the $\eta$ function generates 12 syntactically different BPMN subprocesses, that are presented in Figure~\ref{fig:ex_combination_2}.
	
	
	Applying this operation generates several syntactically different graphs.
	These graphs are built in a BPMN-like fashion, which allows the appliance of the minimisation rules described in Definition~\ref{def:minimisation_rules}.
	The applications of these rules returns a set of graphs that are now semantically different.
	For each of them, a copy of $G$ is made, in which the exclusive split from which these graphs were produced is replaced by the current generated graph.
	Among all these copies, only the ones not creating any syntactic livelock, nor violating any desired mutual exclusion, are kept, while the others are discarded.
	They are called \textit{syntactically compliant processes}.
	
	\begin{definition}[Syntactically Compliant BPMN Process]
		Let $\graph$ be a BPMN process.
		$G$ is said to be \textnormal{syntactically compliant} if $\forall v \in V$ such that $\typeof{v} = \bpmnpargwsplit,\ v$ is \textnormal{syntactically compliant}.
	\end{definition}
	
	\begin{remark}
		A BPMN process containing no parallel split gateway is trivially considered as syntactically compliant.
	\end{remark}
	
	\begin{definition}[Syntactically Compliant Parallel Split Gateway]
		Let $\graph$ be a graph.
		$\forall v \in V$ such that $\typeof{v} = \bpmnpargwsplit,\ v$ is said to be \textnormal{syntactically compliant} if and only if:
		
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item[---] $v$ does not create any \textnormal{syntactic livelock} (i.e., it complies with Definition~\ref{def:infinite_recursion});
			\item[---] $v$ does not break any \textnormal{desired mutual exclusion}, i.e., $\forall v_1, v_2 \in \childrenof{v},\ v_1 \neq v_2:$ 
			
			$(\forall t_1 \in T_1,\ \nexists t_2 \in T_2\ \vert\ t_2 \in \mutexesof{t_1})
			\ \land \
			(\forall t_2 \in T_2,\ \nexists t_1 \in T_1\ \vert\ t_1 \in \mutexesof{t_2})$
			
			where $\forall i \in \{1,2\},\ T_i = \bigcup\limits_{p \in \pathsof{G}{v_i}} \tasksop{\rslice{p}{\sync{\pathsof{G}{v_1} \cup \pathsof{G}{v_2}}}}$
		\end{itemize}
	\end{definition}
	
	\begin{comment}
		\begin{remark}
			If a parallel split gateway $\bpmnpargwsplit$ is syntactically compliant but needs to be synchronised to avoid syntactic livelocks, then the necessary parallel merge gateway $\bpmnpargwmerge$ replaces the original exclusive merge gateway $\bpmnxorgwmerge$ present in $G$.
		\end{remark}
	\end{comment}
	
	\subsubsection{Inserting Parallel Merges}
	
	Each copy of $G$ now contains its parallel split gateways, but no parallel merge gateways yet.
	The insertion of these parallel merge gateways, essential to prevent deadlocks and livelocks in the process, is done in two sequential steps.
	First, the parallel split gateways previously added are analysed to check whether they require a synchronisation node to avoid creating syntactic livelocks in the process.
	If this is the case, a parallel merge gateway is inserted before this synchronisation node, and becomes the new synchronisation node of the parallel split.
	This ensures that the parallel split gateway will not create syntactic livelocks in the final process.
	Next, the remaining exclusive merge gateways of the BPMN process are checked to see whether their closest common ancestor is a parallel split.
	If this is the case, a parallel version of this gateway may not suffer from deadlocks, so it is switched to a parallel gateway.
	
	\subsection{Detection of Deadlocks/Livelocks and Parallelism Removal}
	
	Our previous modifications of the copies of $G$ introduced parallelism in them.
	Although performing this parallelisation phase carefully, it is rather complex to ensure the absence of deadlocks or livelocks at design time by performing only a syntactic analysis of the process.
	However, such behaviours can be easily detected when \textit{executing} the BPMN process.
	
	\begin{definition}[(Execution) Deadlock]
		Let $\graph$ be a BPMN process.
		$G$ contains \textnormal{a(n execution) deadlock} whenever $\exists C \in \confset{G}$ such that:
		
		\begin{itemize}
			\setlength\itemsep{-0.6em}
			\item[---] $C = \pushtokens{C}$;
			\item[---] $C$ is not a \textnormal{final configuration}.
		\end{itemize}
	\end{definition}
	
	\begin{definition}[(Execution) Livelock]
		Let $\graph$ be a BPMN process.
		$G$ contains \textnormal{a(n execution) livelock} whenever $\exists C, C' \in \confset{G}$ such that:
		
		\begin{itemize}
			\setlength\itemsep{-0.6em}
			\item[---] $\forall n \in C,\ C[n] = 0 \Leftrightarrow C'[n] = 0$;
			\item[---] $\forall n \in C,\ C'[n] \geq C[n]$;
			\item[---] $\exists n \in C$ such that $C'[n] > C[n]$.
		\end{itemize}
	\end{definition}
	
	\subsubsection{Detection of Deadlocks/Livelocks}
	
	The detection of such configurations is based on simulation of the given BPMN process.
	However, the simulation that we use to detect such erroneous configurations slightly differs from the one presented in Section~\ref{sub:exec_flow}.
	Indeed, in Section~\ref{sub:exec_flow}, we perform one simulation of the process, representing one of its possible executions.
	Here, we want to ensure that there is no possible execution of the process that reaches a deadlock or a livelock.
	In our context, there is a single type of node possibly making the execution of a process differ from another: the exclusive split gateway.
	Indeed, when a token reaches this node, it is sent to any of its children nodes, non-deterministically.
	To ensure that the detection performs on each possible configuration of the process, the solution that we opted for consists in duplicating the current configuration every time a token must be sent away from an exclusive split gateway.
	The simulation no longer returns a single history \history, but a set of histories $S_{\history} = \{\history_1, ..., \history_n\}$, each of which corresponds to a possible execution of the process.
	However, this modification introduces a major issue: a simulation may no longer terminate.
	Originally, simulating a correct process (i.e., without deadlock/livelock) necessarily terminates, due to the semantics of the different BPMN operators, and to the fact that the children of an exclusive split gateway are probabilistically chosen.
	From now on, as all the children of an exclusive split gateway receive a token from their parent, certain configurations may remain in a state where, for instance, a token is continuously circulating through a strongly connected component of the process.
	To avoid such situations, the simulation now makes use of a \textit{fixed point} analysis.
	
	\begin{definition}[Fixed Point]
		Let $\graph$ be a BPMN process.
		$\confset{G}$ contains a \textnormal{fixed point} whenever $\exists C, C' \in \confset{G}$ such that:
		\begin{itemize}
			\setlength\itemsep{-0.5em}
			\item[---] $\forall n \in C,\ C[n] = C'[n]$;
			\item[---] $\forall n' \in C',\ C[n'] = C'[n']$.
		\end{itemize}
	\end{definition}
	
	When a fixed point is reached, the simulation stops generating all the possible configurations, and is asked to terminate.
	This is ensured by a mechanism that forces the simulator to transmit the tokens of an exclusive split gateway only to its child that is the closest to an end event.
	When the simulation has terminated, the set of histories $S_\history$ is analysed to verify whether there exists an history $\history \in S_\history$ containing a deadlock or a livelock.
	If not, the BPMN process remains as is.
	Otherwise, some of its parallel elements have to be removed.
	
	\subsubsection{Parallelism Removal}
	
	If the deadlock/livelock detector found a deadlock or a livelock in the current BPMN process, this process has to be modified.
	Although being rather simple to detect deadlocks/livelocks in processes, it is more difficult to identify their sources.
	For instance, a node holding a token in a deadlock configuration may not be the source of that deadlock.
	The simplest solution that we found to identify the source of such errors so far consists in removing step by step the parallel gateways of the BPMN process, until reaching a graph containing no deadlock/livelock.
	The removal is made in a simple way: each parallel gateway of the process is replaced by an exclusive one, which leads to the generation of several new BPMN processes, each of them containing one less parallel gateway.
	If the removed gateway is a parallel merge gateway, and if this gateway is the mandatory synchronisation node of a parallel split gateway, this parallel split gateway is also replaced by an exclusive split gateway to avoid syntactic livelocks.
	Among all the deadlock/livelock-free generated BPMN processes, the one with the largest number of parallel tasks is elected as best candidate. 
	This procedure is summarised in Algorithm~\ref{alg:generate_best_par_process}.
	This final BPMN process now satisfies a new set of constraints $\mathit{Cons}_4$.
	
	\begin{algorithm}
		\caption{Algorithm for Generating the Most Parallel Process}
		\label{alg:generate_best_par_process}
		
		\begin{flushleft}
			\textbf{Inputs:} $\graph$ (BPMN Process), $M_S$ (Split with Mandatory Merges)\\
			\textbf{Output:} $G_P$ (Most Parallel BPMN Process)
		\end{flushleft}
		
		\begin{algorithmic}[1]
			\State $\mathit{S_{next}} \gets []$
			\State $G_P \gets \bot$
			\State
			\If{$\lnot$\Call{hasDeadlockOrLivelock}{$G$}}
			\State $G_P \gets$ \Call{getMostParallelProcessBetween}{$G,\ G_P$}
			\EndIf
			\State
			\For{$v \in V$}
			\If{$\typeof{v} = \bpmnpargwsplit$} 
			\State $G' \gets$ \Call{copy}{G} where $\typeof{v} = \bpmnxorgwsplit$ \Comment{$v$ is a $\bpmnpargwsplit \Rightarrow v$ becomes a $\bpmnxorgwsplit$}
			\State $\mathit{S_{next}} \gets \mathit{S_{next}} \cup [G']$
			\ElsIf{$\typeof{v} = \bpmnpargwmerge$} %\Comment{Copy $G$ and replace $v$ by an exclusive merge gateway}
			\If{$M_S[v] \neq \bot$}			\Comment{$v$ is a mandatory merge $\Rightarrow v$ and $M_S[v]$ become $\bpmnxorgw$}
			\State $G' \gets$ \Call{copy}{G} where $\typeof{v} = \bpmnxorgwmerge$ and $\typeof{M_S[v]} = \bpmnxorgwsplit$
			\Else	\Comment{$v$ is not a mandatory merge $\Rightarrow$ only $v$ becomes a $\bpmnxorgw$}
			\State $G' \gets$ \Call{copy}{G} where $\typeof{v} = \bpmnxorgwmerge$
			\EndIf
			\State $\mathit{S_{next}} \gets \mathit{S_{next}} \cup [G']$
			\EndIf 
			\EndFor
			\State
			\For{$G' \in \mathit{S_{next}}$}
			\State $G_P \gets $ \Call{getMostParallelProcessBetween}{\Call{this}{$G'$}, $G_P$}
			\EndFor
			\State
			\State \Return $G_P$
		\end{algorithmic}
	\end{algorithm}
	
\end{document}