
\documentclass{article}
\usepackage[utf8]{inputenc}
%\usepackage{hyperref}
\title{Mutual Exclusions Insertion Formalisation}
\author{Quentin Nivon, Gwen Sala{\"u}n}


\usepackage{a4wide}
\usepackage[export]{adjustbox}
\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{algpseudocode}
%\usepackage{alltt}
\usepackage{AMMALanguages}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[toc,page]{appendix}
\usepackage{array} 							    % needed for newcolumntype
%\usepackage[french]{babel}
\usepackage[altpo, epsilon]{backnaur}
\usepackage{booktabs}
\usepackage{cancel}
\usepackage{caption}
\usepackage{comment}
%\usepackage{courier}
\usepackage{enumitem}
\usepackage{epigraph}				 			% Citations en début de chapitre
\usepackage{fancyhdr} 							% en-tete et pied de page, pour plus d'info: texdoc fancyhdr
\usepackage{float}
\usepackage[T1]{fontenc} 						% fontenc permet entre autre de rechercher des mots avec accents dans les PDF produits
\usepackage{footnote}
\usepackage{framed}
%\usepackage{graphicx}
\usepackage{hhline}
\usepackage[nodisplayskipstretch]{setspace}		% pas en ordre alphabétique car doit être importé avant "hyperref" pour que les hyperliens des notes de bas de page fonctionnent correctement
\usepackage[hidelinks]{hyperref}
%\usepackage[latin1]{inputenc}      			% latin1 n'encode pas la ligature oe, utiliser {\oe}
%\usepackage[utf8]{inputenc}
\usepackage{listing}
\usepackage{listings}
\usepackage{lmodern}			    			% une police OK pour l'encodage en T1
\usepackage{makecell}
\usepackage{mathtools}
%\usepackage[a4paper]{meta-donnees} 		    % Pour la page de garde de l'université de Grenoble. (temporarily commented)
\usepackage{minitoc}
%\usepackage{msc} 								% Message Sequence Diagrams
%\usepackage{multicol} 						    % to allow listings on double column
\usepackage{multirow}
%\usepackage{orcidlink}
\usepackage{parskip}          					% paragraphe : pas d'indentation, un saut de ligne
\usepackage{pdflscape}
\usepackage[final]{pdfpages}	    			% to add the pdf pages
\usepackage{pgfplots}
\usepackage{pifont}

\usepackage{soul}
\usepackage[labelformat=simple, belowskip=1ex]{subcaption}
%\usepackage{subfig}             				% plusieurs figures en une
%\usepackage{subfigure}
\usepackage{tablefootnote}
%\usepackage{tabularx}             				% table qui s'étendent sur la largeur de la page
\usepackage{tikz}
\usetikzlibrary{fit} 
\usepackage{tikz-bpmn}
\usepackage{titlesec}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
%\usepackage{txfonts}
\usepackage{url}
%\usepackage{verbatim}
%\usepackage{xspace}

%------------------------------------------------- NEW COMMANDS --------------------------------------------------

\newcommand{\absorbance}[1]{\ensuremath{\mathtt{absorbance}(#1)}}
\newcommand{\acyclicpath}{p_{\cancelledcirclearrow}}
\newcommand{\acyclicisreachablefrom}[2]{#1 \xrightarrow{R_{\cancelledcirclearrow}} #2}
\newcommand{\aetof}[1]{\ensuremath{\mathit{AET}(#1)}}
\newcommand{\algendif}{\text{\textbf{end if}}}
\newcommand{\algif}{\text{\textbf{if }}}
\newcommand{\algobreak}{\text{\textbf{break}}}
\newcommand{\algreturn}{\State \Return}
\newcommand{\algthen}{\text{\textbf{then}}}
%\newcommand{\allchoicesop}[1]{\texttt{allChoices}(#1)}
\newcommand{\allchoicesop}[1]{\ensuremath{\mathcal{C}}(#1)}
%\newcommand{\allcondstructsop}[1]{\texttt{CS}(#1)}
\newcommand{\allcondstructsop}[1]{\ensuremath{\mathcal{S}(#1)}}
%\newcommand{\allgraphsop}[1]{\texttt{allGraphs}(#1)}
\newcommand{\allgraphsop}[1]{\ensuremath{\mathcal{G}}(#1)}
%\newcommand{\alllabelsop}[1]{\texttt{allLabels}(#1)}
\newcommand{\alllabelsop}[1]{\ensuremath{\Sigma}(#1)}
%\newcommand{\allloopsop}[1]{\texttt{allLoops}(#1)}
\newcommand{\allloopsop}[1]{\ensuremath{\mathcal{L}}(#1)}
%\newcommand{\allnodesop}[1]{\texttt{allNodes}(#1)}
\newcommand{\allnodesop}[1]{\ensuremath{\mathcal{V}}(#1)}
\newcommand{\allstructsop}[1]{\texttt{allStructs}(#1)}
%\newcommand{\alltasksop}[1]{\texttt{allTasks}(#1)}
\newcommand{\alltasksop}[1]{\ensuremath{\mathcal{T}}(#1)}
\newcommand{\anyof}[2]{\ensuremath{\mathtt{any}(#1, #2)}}
\newcommand{\anyofproba}[2]{\ensuremath{\mathtt{any}_p(#1, #2)}}
\newcommand{\anyofprobaunique}[1]{\ensuremath{\mathtt{any}_p(#1)}}
\newcommand{\anyofunique}[1]{\ensuremath{\mathtt{any}(#1)}}
\newcommand{\bnfterm}[1]{$\langle$#1$\rangle$}
%\newcommand{\boundary}[1]{\texttt{boundary}(#1)}
\newcommand{\boundary}[1]{\ensuremath{\partial(#1)}}
\newcommand{\bpmnacyclicpaths}[1]{\mathcal{\widehat{P}}_{#1}^{0}}
\newcommand{\bpmnacyclicpathsof}[2]{\mathcal{\widehat{P}}_{#1}^{0}(#2)}
\newcommand*{\bpmnendevent}{\tikz[baseline=-.25em]{\node[circle, draw, ultra thick, minimum width=1.2em, minimum height=1.2em] () {e};}}
\newcommand*{\bpmnorgw}{\tikz[baseline=-.25em]{\node[shape=ID,draw,inner sep=0pt, minimum size=1.5em]  (X) {};}}
\newcommand*{\bpmnpargw}{\tikz[baseline=-.25em]{\node[shape=PF,draw,inner sep=0pt, minimum size=1.5em] (X) {};}}
\newcommand{\bpmnpargwmerge}{\ensuremath{\bpmnpargw_M}}
\newcommand{\bpmnpargwmergetype}{\bpmnpargwmerge}
\newcommand{\bpmnpargwsplit}{\ensuremath{\bpmnpargw_S}}
\newcommand{\bpmnpargwsplittype}{\bpmnpargwsplit}
\newcommand{\bpmnpaths}[1]{\mathcal{P}_{#1}^{0}}
\newcommand{\bpmnpathsof}[2]{\mathcal{P}_{#1}^{0}(#2)}
\newcommand*{\bpmnstartevent}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {s};}}
\newcommand{\bpmntask}[1]{\tikz[baseline=-.25em]{\node[rectangle, draw, black, minimum width=2em, minimum height=1.5em, rounded corners] () {#1};}}
\newcommand{\bpmnredtask}[1]{\tikz[baseline=-.25em]{\node[rectangle, draw, red, minimum width=2em, minimum height=1.5em, rounded corners] () {\textcolor{red}{#1}};}}
\newcommand*{\bpmnxorgw}{\tikz[baseline=-.25em]{\node[shape=XOR,draw,inner sep=0pt, minimum size=1.5em] (X) {};}}
\newcommand{\bpmnxorgwmerge}{\ensuremath{\bpmnxorgw_M}}
\newcommand{\bpmnxorgwmergetype}{\bpmnxorgwmerge}
\newcommand{\bpmnxorgwsplit}{\ensuremath{\bpmnxorgw_S}}
\newcommand{\bpmnxorgwsplittype}{\bpmnxorgwsplit}
\newcommand{\cancelledcirclearrow}{\rotatebox[origin=c]{180}{\ensuremath{\cancel{\circlearrowright}}}}
\newcommand{\cardof}[1]{\lvert #1 \rvert}
\newcommand{\childrenof}[1]{\ensuremath{\mathtt{child}(#1)}}
%\newcommand{\childrenof}[1]{\mathit{children(#1)}}
%\newcommand{\childrenof}[1]{\mathit{#1.children}}
\newcommand{\choiceop}{`$\vert$' }
\newcommand{\choiceopw}{`$\vert$'}
\newcommand{\closedarray}[2]{[#1...#2]}
\newcommand{\closestboundary}[2]{\ensuremath{\mathtt{boundary}^*(#1, #2)}}
%\newcommand{\closestcondstruct}[1]{\ensuremath{\mathtt{CCS}(#1)}}
\newcommand{\closestcondstruct}[1]{\ensuremath{\mathcal{S}^*(#1)}}
%\newcommand{\closestnode}[1]{\ensuremath{\mathtt{CN}(#1)}}
\newcommand{\closestnode}[1]{\ensuremath{\mathcal{V}^*(#1)}}
%\newcommand{\closestseqgraph}[1]{\ensuremath{\mathtt{CSG}(#1)}}
\newcommand{\closestseqgraph}[1]{\ensuremath{\mathcal{G}^*(#1)}}
\newcommand{\cluster}[1]{\ensuremath\textit{cluster}(#1)}
\newcommand{\code}[1]{\textsf{\small #1}}
\newcommand{\comaop}{`$,$' }
\newcommand{\comaopw}{`$,$'}
%\newcommand{\confset}[1]{\texttt{Hist}(#1)}
\newcommand{\confset}[1]{\history(#1)}
\newcommand{\constraints}{\mathit{Cons}}
\newcommand{\context}[2]{\ensuremath\textit{context}(#1,#2)}
\newcommand{\contextAux}[3]{\ensuremath\textit{context}(#1,#2,#3)}
%\newcommand{\contextwisemutex}{\vert_{CW}}
\newcommand{\contextwisemutex}[2]{\ensuremath{#1\ \vert_{CW}\ #2}}
\newcommand{\continue}{\text{\textbf{continue}}}
%\newcommand{\costop}[1]{\texttt{cost}(#1)}
\newcommand{\costop}[1]{\ensuremath{\mathtt{cost}(#1)}}
\newcommand{\csg}[2]{\ensuremath\textit{csg}(#1,#2)}
\newcommand{\cyclicpath}{p_{\mycirclearrow}}
\newcommand{\cyclicisreachablefrom}[2]{#1 \xrightarrow{R_{\mycirclearrow}} #2}
%\newcommand{\defequals}{\stackrel{\mathclap{\normalfont\mbox{def}}}{=}}
\newcommand{\defequals}{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}
\newcommand{\degreeof}[1]{\ensuremath{\mathtt{deg}(#1)}}
\newcommand{\dependencies}{\ensuremath{\mathtt{Dep}}}
\newcommand{\distanceof}[2]{\ensuremath{\|(#1,#2)\|}}
%\newcommand{\durationop}[1]{\ensuremath{\mathtt{duration}(#1)}}
\newcommand{\durationop}[1]{\ensuremath{\delta(#1)}}
\newcommand{\example}{\textit{Example. }}
\newcommand{\expressionsset}{\ensuremath{\mathtt{Expr}}}
\newcommand{\fourspaces}{\space \space \space \space}
\newcommand{\genop}[2]{\ensuremath{\mathtt{gen}(#1,#2)}}
\newcommand{\geniop}[3]{\ensuremath{\mathtt{gen}_{P_{#1}\!}(#2,#3)}}
\newcommand{\geniiop}[4]{\ensuremath{\mathtt{gen}_{P_{#1}\!}^{#2}(#3,#4)}}
\newcommand{\GFL}{\ensuremath G_\textit{FL}}
\newcommand{\GLF}{\ensuremath G_\textit{LF}}
\newcommand{\GlobalTimer}{\ensuremath{\mathfrak{T}}}
\newcommand{\GlobalTimerOf}[1]{\ensuremath{\mathfrak{T}(#1)}}
\newcommand{\graph}{G~=~(V,~E,~\Sigma)}
\newcommand{\graphparam}[1]{G_{#1}=(V_{#1},E_{#1},\Sigma_{#1})}
%\newcommand{\graph}{G~=~(V,~E,~\Sigma,~I)}
\newcommand{\greaterentirepart}[1]{\ensuremath{\lceil #1 \rceil}}
%\newcommand{\holdtoken}[1]{\dot{#1}}
\newcommand{\history}{\ensuremath{\mathcal{H}}}
\newcommand{\holdtoken}[1]{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily $\bullet$}}}{#1}}}
\newcommand{\iat}{\ensuremath{\mathit{IAT}}}
\newcommand{\indexof}[1]{\mathtt{index}(#1)}
\newcommand{\infreach}{$\infty$-reachability}
\newcommand{\initialeventtype}{\texttt{initial event}}
\newcommand{\insertop}{\ensuremath{\mathtt{ins}}}
\newcommand{\isreachablefrom}[2]{#1 \xrightarrow{R} #2}
\newcommand{\labelof}[1]{\sigma(#1)}
\newcommand{\lclosedarray}[2]{[#1...#2[}
\newcommand{\loopmandaop}{`$+$' }
\newcommand{\loopop}{`$*$' }
\newcommand{\loopoptioop}{`$?$' }
\newcommand{\loopopw}{`$*$'}
\newcommand{\loops}{\ensuremath{\mathtt{Loops}}}
\newcommand{\lowerentirepart}[1]{\ensuremath{\lfloor #1 \rfloor}}
\newcommand{\lslice}[2]{#1[#2:]}
\newcommand{\ltland}{\ensuremath{\land}}
\newcommand{\ltlF}{\textbf{F}}
\newcommand{\ltlG}{\textbf{G}}
\newcommand{\ltlimplies}{\ensuremath{\Rightarrow}}
\newcommand{\ltlN}{\textbf{N}}
\newcommand{\ltlnot}{\ensuremath{\lnot}}
\newcommand{\ltlor}{\ensuremath{\lor}}
\newcommand{\ltlU}{\textbf{U}}
\newcommand{\ltlW}{\textbf{W}}
\newcommand{\maxnbinstances}{\ensuremath{I_{\mathit{max}}}}
\newcommand{\move}[2]{\ensuremath\textit{move}(#1,#2)}
\newcommand{\moveup}{$\mu$ }
\newcommand{\moveuprec}{$\mu_r$ }
\newcommand{\mutex}[2]{\ensuremath{#1\ \vert\ #2}}
%\newcommand{\mutex}{\vert}
\newcommand{\mutexesof}[1]{\ensuremath{\mathtt{mutex}(#1)}}
\newcommand{\mycirclearrow}{\rotatebox[origin=c]{180}{\ensuremath{\circlearrowright}}}
\newcommand{\mycmark}{\ding{51}}%
\newcommand{\myendeventtype}{\texttt{end event}}
\newcommand{\mysubitem}[2]{{\setlength\itemindent{15pt} \item[#1] #2}}
\newcommand{\myxmark}{\ding{55}}%
\newcommand{\namedgraph}[1]{#1~=~(V,~E,~\Sigma,~I)}
\newcommand{\naturals}{\ensuremath{\mathbb{N}}}
\newcommand{\newtask}[1]{\textit{#1}}
\newcommand{\normal}[2]{\ensuremath{\mathcal{N}(#1, #2)}}
\newcommand{\normalise}[1]{\ensuremath{\mathtt{norm}(#1)}}
\newcommand{\normalisei}[1]{\ensuremath{\mathtt{norm}_i(#1)}}
\newcommand{\normaliseone}[1]{\ensuremath{\mathtt{norm}_1(#1)}}
\newcommand{\normalisetwo}[1]{\ensuremath{\mathtt{norm}_2(#1)}}
\newcommand{\normalisethree}[1]{\ensuremath{\mathtt{norm}_3(#1)}}
\newcommand{\openarray}[2]{]#1...#2[}
\newcommand{\parallelsof}[1]{\ensuremath{\mathtt{par}(#1)}}
\newcommand{\paramedconstraints}[1]{\mathit{Cons_{#1}}}
\newcommand{\paramedgraph}[1]{G_{#1}~=~(V_{#1},~E_{#1},~\Sigma_{#1},~I_{#1})}
%\newcommand{\parentof}[1]{\texttt{parent}(#1)}
\newcommand{\parentof}[1]{\ensuremath{\mathtt{parent}(#1)}}
%\newcommand{\parentsof}[1]{\mathit{#1.parents}}
\newcommand{\parentsof}[1]{\ensuremath{\mathtt{parents}(#1)}}
\newcommand{\parop}{`$\&$' }
\newcommand{\paropw}{`$\&$'}
\newcommand{\paths}[1]{\mathcal{P}_{#1}}
\newcommand{\pathsof}[2]{\mathcal{P}_{#1}(#2)}
\newcommand{\pLF}{\ensuremath p_\textit{LF}}
\newcommand{\predecessorsof}[1]{\ensuremath{\mathtt{pred}(#1)}}
%\newcommand{\predecessorsof}[1]{\mathit{#1.predecessors}}
%\newcommand{\pushtokens}[1]{\texttt{push}(#1)}
\newcommand{\pushtokens}[1]{\ensuremath{\mathtt{push}(#1)}}
\newcommand{\rclosedarray}[2]{]#1...#2]}
\newcommand{\redtext}[1]{\textcolor{red}{#1}}
\newcommand{\redbold}[1]{\textcolor{red}{\ensuremath{\mathbf{#1}}}}
\newcommand{\reduceop}[1]{\texttt{reduce}(#1)}
\newcommand{\Rho}{\ensuremath{P}}
\newcommand{\remove}[2]{\ensuremath\textit{remove}(#1,#2)}
%\newcommand{\removealltasksop}[2]{\texttt{remove}^*(#1, #2)}
\newcommand{\removealltasksop}[2]{\ensuremath{\mathtt{rem}^*(#1, #2)}}
\newcommand{\removestar}[2]{\ensuremath\textit{rem}^*(#1,#2)}
\newcommand{\removetaskop}[2]{\ensuremath{\mathtt{rem}(#1, #2)}}
\newcommand{\resname}[1]{\textsf{#1}}
\newcommand{\resource}[1]{\textsf{#1}}
\newcommand{\resourcesop}[2]{\ensuremath{\rho(#1, #2)}}
\newcommand{\respool}{\ensuremath{\Rho}}
\newcommand{\respoolinfty}{\ensuremath{\Rho_\infty}}
\newcommand{\restrictionof}[2]{\ensuremath{#1\restriction_{#2}}}
\newcommand{\rexample}{\textit{Running example. }}
\newcommand{\rootof}[1]{\ensuremath{\mathtt{root}(#1)}}
\newcommand{\rslice}[2]{#1[:#2]}
\newcommand{\sandgwmerge}{\andgw$_M$ }
\newcommand{\sandgwsplit}{\andgw$_S$ }
%\newcommand{\scoreop}[1]{\texttt{score}(#1)}
\newcommand{\scoreop}[1]{\ensuremath{\mathtt{score}(#1)}}
\newcommand{\sendtoken}[2]{#1 \xrightarrow{\token} #2}
\newcommand{\seqgraph}{\ensuremath{G_< = (\seqgraphnodes, \seqgraphedges, \seqgraphlabels)}}
\newcommand{\seqgraphchoice}{\ensuremath{\bpmnxorgw_C}}
%\newcommand{\seqgraphchoicetype}{\seqgraphchoice}
\newcommand{\seqgraphchoicetype}{\ensuremath{\mathcal{C}}}
\newcommand{\seqgraphedge}{\ensuremath{e_<}}
\newcommand{\seqgraphedges}{\ensuremath{E_<}}
\newcommand{\seqgraphfirstnode}[1]{\ensuremath{\mathtt{first}(#1)}}
%\newcommand{\seqgraphgraphtype}{G}
\newcommand{\seqgraphgraphtype}{\ensuremath{\mathcal{G}}}
\newcommand{\seqgraphlastnode}[1]{\ensuremath{\mathtt{last}(#1)}}
\newcommand{\seqgraphloop}{\ensuremath{\bpmnxorgw_L}}
%\newcommand{\seqgraphlooptype}{\seqgraphloop}
\newcommand{\seqgraphlooptype}{\ensuremath{\mathcal{L}}}
\newcommand{\seqgraphlabels}{\ensuremath{\Sigma_<}}
\newcommand{\seqgraphnode}{\ensuremath{v_<}}
\newcommand{\seqgraphnodes}{\ensuremath{V_<}}
\newcommand{\seqgraphparent}[1]{\ensuremath{\mathtt{parent}}(#1)}
\newcommand{\seqgraphpred}[1]{\ensuremath{\mathtt{pred}(#1)}}
\newcommand{\seqgraphsucc}[1]{\ensuremath{\mathtt{succ}(#1)}}
\newcommand{\seqgraphtasktype}{\ensuremath{\mathcal{T}}}
\newcommand{\seqop}{`$<$' }
\newcommand{\seqopw}{`$<$'}
\newcommand{\sledom}{\Relbar\joinrel\mathrel{|}}
\newcommand{\slice}[3]{#1[#2:#3]}
\newcommand{\SosSpace}{\ \ \ \ \ }
\newcommand{\specialcell}[2][c]{%
	\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}
}
%\newcommand{\strongmutex}{\vert_S}
\newcommand{\strongmutex}[2]{\ensuremath{#1\ \vert_S\ #2}}
\newcommand{\successorsof}[1]{\ensuremath{\mathtt{succ}(#1)}}
%\newcommand{\successorsof}[1]{\mathit{#1.successors}}
\newcommand{\swcetop}[2]{\texttt{SWCET}(#1, #2)}
\newcommand{\swcetopinf}[1]{\ensuremath{\texttt{SWCET}(#1, \Rho_{\infty})}}
\newcommand{\sxorgwmerge}{\xorgw$_M$ }
\newcommand{\sxorgwsplit}{\xorgw$_S$ }
\newcommand{\sync}[1]{\mathtt{sync}(#1)}
\newcommand{\task}[1]{\textsf{#1}}
\newcommand{\taskname}[1]{\textsf{#1}}
%\newcommand{\tasksop}[1]{\texttt{tasks}(#1)}
\newcommand{\tasksop}[1]{\ensuremath{\mathtt{tasks}(#1)}}
\newcommand{\tasktype}{\texttt{task}}
\newcommand{\token}{\bullet}
\newcommand{\transition}[2]{#1~\rightarrow~#2}
\newcommand{\treeanytype}[1]{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {#1};}}
\newcommand{\treechoicetype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {\ensuremath{\vert}};}}
\newcommand{\treecomatype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.5em, minimum height=1.5em] () {,};}}
\newcommand{\treelooptype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {*};}}
\newcommand{\treenode}[1]{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1em, minimum height=1em] () {\ensuremath{#1}};}}
\newcommand{\treeop}[1]{\ensuremath{T_{\preceq}(#1)}}
\newcommand{\treepartype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {\&};}}
\newcommand{\treeseqtype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {<};}}
\newcommand{\treetasktype}{\tikz[baseline=-.25em]{\node[circle, draw, minimum width=1.2em, minimum height=1.2em] () {t};}}
\newcommand{\tupleof}[2]{(#1, ..., #2)}
%\newcommand{\typeof}[1]{\texttt{type}(#1)}
\newcommand{\typeof}[1]{\ensuremath{\theta(#1)}}
\newcommand{\uniform}[2]{\ensuremath{\mathcal{U}_{[#1, #2]}}}
\newcommand{\WaitingTasksOP}[2]{\texttt{wait}(#1, #2)}
\newcommand{\wcetop}[2]{\texttt{WCET}(#1, #2)}
\newcommand{\wcetopinf}[1]{\texttt{WCET}(#1, \ensuremath{R_\infty})}
%\newcommand{\weakmutex}{\vert_W}
\newcommand{\weakmutex}[2]{\ensuremath{#1\ \vert_W\ #2}}

%------------------------------------------------- RENEW COMMANDS --------------------------------------------------

\renewcommand\thesubfigure{(\alph{subfigure})}

%------------------------------------------------- DECLARE MATH OPERATOR -------------------------------------------

\DeclareMathOperator{\anc}{anc}
\DeclareMathOperator{\des}{des}
\DeclareMathOperator{\find}{find}
\DeclareMathOperator{\lca}{LCA}
\DeclareMathOperator{\none}{None}
\DeclareMathOperator{\pred}{pred}
\DeclareMathOperator{\merge}{merge}
\DeclareMathOperator{\reduce}{reduce}
\DeclareMathOperator{\riu}{riu}
\DeclareMathOperator{\size}{size}
\DeclareMathOperator{\smallpred}{p}
\DeclareMathOperator{\suc}{succ}
\DeclareMathOperator{\swap}{swap}
\DeclareMathOperator{\troot}{root}
\DeclareMathOperator{\typ}{type}
\DeclareMathOperator{\type}{type}

%------------------------------------------------------ NEW THEOREM ------------------------------------------------

\newtheorem{definition}{Definition}
%\newtheorem{proof}{Proof}				% commenter si problème de compilation sur linux/décommenter si problème de compilation sur windows
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}

%--------------------------------------------------------- DIVERS --------------------------------------------------

\pagestyle{fancy}
\pgfplotsset{width=7cm,compat=1.18}
%\setlength{\levelheight}{0.9\levelheight}





%\lstset{
	%numbers=left,
	%numberstyle=\tiny,
	%language={Java},
	%mathescape=true,
	%flexiblecolumns=true,
	%morekeywords={def,Int,call,method,var,assert,share,unshare,acquire,release,fork,join,free,invariant,requires,ensures,acc,rd,old},
	%basicstyle=\sffamily\small,
	%moredelim=[is][\itshape]{@}{@},
	%stepnumber=1,
	%numbersep=2pt} 

%\input{cadp-mcl.sty}

\lstdefinelanguage{LOTOS}
{
	morekeywords=[1]{accept,actualizedby,any,behaviour,behavior,choice,
		endlib,endproc,endspec,endtype,eqns,exit,
		for,forall,formaleqns,formalopns,formalsorts,hide,
		i,in,is,let,library,noexit,
		of,ofsort,opnnames,opns,par,process,
		renamedby,sortnames,sorts,specification,stop,type,
		using,where},
	morekeywords=[2]{atomic,comparedby,constructor,enumeratedby,external,implementedby,
		iteratedby,printedby},
	morekeywords=[3]{BasicNaturalNumber,Bit,BitNatRepr,BitString,Bool,Boolean,
		DecDigit,DecNatRepr,DecString,HexDigit,HexNatRepr,HexString,
		NatRepresentations,Nat,NaturalNumber,OctDigit,Octet,OctetString,
		OctNatRepr,OctString,Set,String},
	morekeywords=[4]{false,true},
	morekeywords=[5]{and,Bit1,Bit2,Bit3,Bit4,Bit5,
		Bit6,Bit7,Bit8,Card,eq,ge,
		gt,iff,implies,Includes,Insert,Ints,
		IsIn,IsSubsetOf,le,Length,lt,Minus,
		NatNum,ne,not,NotIn,or,Remove,
		Reverse,Succ,Union,xor},
	otherkeywords={<,>,+,-,/,!,
		?,;,**,==,<>,<=,
		>=,=>,>>,[>,||,|[,
		]|,[],|||},
	sensitive=false,
	morecomment=[s]{(*}{*)}
}[keywords,comments]


%% Listings definitions for the LOTOS language
%% produced by Syntax Editor Configuration Tool <cadp@inria.fr>
%% version 1.7:LOTOS+1.7:SECT

\lstdefinelanguage{LOTOS}
{
	morekeywords=[1]{accept,actualizedby,any,behaviour,behavior,choice,
		endlib,endproc,endspec,endtype,eqns,exit,
		for,forall,formaleqns,formalopns,formalsorts,hide,
		i,in,is,let,library,noexit,
		of,ofsort,opnnames,opns,par,process,
		renamedby,sortnames,sorts,specification,stop,type,
		using,where},
	morekeywords=[2]{atomic,comparedby,constructor,enumeratedby,external,implementedby,
		iteratedby,printedby},
	morekeywords=[3]{BasicNaturalNumber,Bit,BitNatRepr,BitString,Bool,Boolean,
		DecDigit,DecNatRepr,DecString,HexDigit,HexNatRepr,HexString,
		NatRepresentations,Nat,NaturalNumber,OctDigit,Octet,OctetString,
		OctNatRepr,OctString,Set,String},
	morekeywords=[4]{false,true},
	morekeywords=[5]{and,Bit1,Bit2,Bit3,Bit4,Bit5,
		Bit6,Bit7,Bit8,Card,eq,ge,
		gt,iff,implies,Includes,Insert,Ints,
		IsIn,IsSubsetOf,le,Length,lt,Minus,
		NatNum,ne,not,NotIn,or,Remove,
		Reverse,Succ,Union,xor},
	otherkeywords={<,>,+,-,/,!,
		?,;,**,==,<>,<=,
		>=,=>,>>,[>,||,|[,
		]|,[],|||},
	sensitive=false,
	morecomment=[s]{(*}{*)}
}[keywords,comments]


%%%%%%%%%%%%%%
%%% Thesis Hugues
%%%%%%%%%%%%%%%%

% ------------------------------ LNT listings ------------------------------

\lstdefinelanguage{LNT}
{morekeywords={
		any, as, break, by, case, comparedby, do, else, elsif, end, eval,
		external, for, function, hide, if, implementedby, in, inout, is,
		list, loop, module, null, of, only, out, par, printedby, process,
		raise, raises, return, select, set, sorted, stop, then, type, var,
		where, while, with, array, channel, disrupt, iteratedby,
		representedby,
		!nat_bits,!nat_inf,!nat_sup,!nat_check,!int_bits,!int_inf,
		!int_sup,!int_check,!string_card,!comparedby,!external,!implementedby,
		!iteratedby,!printedby,!representedby
	},
	otherkeywords={?,|,\#,->,[],||},
	alsoletter={!},
	sensitive=false,
	morecomment=[l]{--},
	morecomment=[s]{(*}{*)},
	morestring=[b]"
}

\lstdefinelanguage{SVL}
{
	morekeywords=[1]{abstraction,all,bag,branching,but,chaos,
		check,comparison,cut,deadlock,divbranching,end,
		expected,fifo,gate,generation,hide,in,
		is,label,labels,leaf,livelock,multiple,
		node,observational,of,par,partial,prio,
		probabilistic,property,reduction,refined,rename,result,
		root,safety,single,smart,stochastic,stop,
		strong,sync,tau-compression,tau-confluence,tau-divergence,tau*.a,
		total,trace,user,using,verify,weak,
		with},
	morekeywords=[2]{\%},
	morekeywords=[3]{acyclic,bdd,bfs,dfs,fly,std},
	morekeywords=[4]{FALSE,TRUE},
	morekeywords=[5]{aldebaran,bcg_min,bcg_cmp,bisimulator,evaluator,evaluator3,
		evaluator4,exhibitor,fc2tools,reductor,xtl},
	% otherkeywords={%
		%                  :,\#,?,==,>=,<=,
		%                  |=,->,||
		%                  %,|[,]|,-||,
		%                  %-|[,|||,-|||
		%                },
	alsoletter={-*.\%},
	sensitive=true,
	morecomment=[l]{--},
	morecomment=[s]{(*}{*)},
	morestring=[b]{'},
	morestring=[b]{"}
}[keywords,comments,strings]

\lstdefinelanguage{MCL}
{
	morekeywords=[1]{among,any,case,choice,continue,do,
		else,elsif,end,end_library,end_macro,exists,
		exit,export,for,forall,from,if,
		in,let,library,loop,macro,mu,
		nil,nu,of,on,repeat,step,
		tau,then,to,until,where,while},
	morekeywords=[2]{bool,nat,natset,int,real,char,
		string},
	morekeywords=[3]{false,true},
	morekeywords=[4]{abs,and,concat,diff,empty,equ,
		implies,index,insert,isin,isalnum,isalpha,
		isdigit,islower,isupper,isxdigit,inter,length,
		not,nth,or,prefix,remove,rindex,
		sign,substr,succ,suffix,tolower,toupper,
		union,xor},
	otherkeywords={
		%+,-,=,/,
		!,^,
		\%,|,<,>,[,],
		@,
		%*,
		?,<>,<=,>=,
		->,-|
	},
	sensitive=false,
	morecomment=[s]{(*}{*)},
	morestring=[b]{'},
	morestring=[b]{"}
}[keywords,comments,strings]

% option générale pour tous les langages
\lstset{
	%  basicstyle=\sffamily\scriptsize,
	basicstyle=\sffamily\footnotesize,
	%basewidth=0.55em,% test for sffamily
	columns=flexible,
	showstringspaces=false,
	language=LNT
}

\lstnewenvironment{lnt}
{\lstset{language=LNT}}
{}

\lstnewenvironment{margelnt}
{\lstset{language=LNT,xleftmargin=8mm}}
{}

\lstnewenvironment{margec}
{\lstset{
		language=C,
		basicstyle=\ttfamily\footnotesize,
		%columns=fixed, % pas joli...
		xleftmargin=8mm
}}
{}

\lstnewenvironment{margesh}
{\lstset{
		language=sh,
		basicstyle=\ttfamily\footnotesize,
		xleftmargin=8mm
}}
{}

\lstnewenvironment{margemcl}
{\lstset{language=MCL,stringstyle=\ttfamily,xleftmargin=8mm}}
{}

\lstnewenvironment{margesvl}
{\lstset{language=SVL,stringstyle=\ttfamily,xleftmargin=8mm}}
{}


\MakeRobust\Call

\begin{document}
	\maketitle
	
	
	The explicit loops---by opposition to the implicit ones induced by cyclic sequential constraints---are the loops belonging to the set of loops called \loops.
	To appear in $G$, each loop $L = (v_1, ..., v_n) \in \loops$ must form a strongly connected component in $G$.
	Depending on the composition of $L$, the insertion is performed differently.
	We can differentiate two major cases: either (i) none of the nodes in $L$ belong to $G$, i.e., $L \cap V = \emptyset$ or (ii) at least one node in $L$ belongs to $G$, i.e., $L \cap V \neq \emptyset$.
	By definition, the nodes $v \in L \setminus V$ cannot be mutually exclusive of any other node, otherwise they would have been added to $G$ in the previous step, nor sequentially constrained to any other node, otherwise they would already belong to $G$.
	Thus, they are not constrained with regards to any other node of $G$.
	
	In case (i), the approach simply consists in connecting all the $v \in L$ to a parallel split gateway $\bpmnpargwsplit$ and to a parallel merge gateway $\bpmnpargwmerge$.
	This construct is then put inside a loop, that is, between an exclusive merge gateway $\bpmnxorgwmerge$ and an exclusive split gateway $\bpmnxorgwsplit$ which is connected to the exclusive merge gateway.
	Once done, the exclusive merge gateway is inserted in $G$ as child of the initial event\footnote{An exclusive split gateway $\bpmnxorgwsplit$ is added if needed.}.
	By doing so, the loop nodes now form a strongly connected component that belongs to $G$, as desired.
	More formally, we have that $G_3 = (V_3, E_3, \Sigma_3)$, where:
	
	\begin{itemize}
		\setlength\itemsep{-0.5em}
		\item[---] $V_3 = V \cup L \cup \{\bpmnxorgwsplit\} \cup \tilde{V}$ ;
		\item[---] $E_3 = E \setminus \{\bpmnstartevent \rightarrow \anyofunique{\childrenof{\bpmnstartevent}}\} \cup \{\bpmnxorgwsplit \rightarrow \bpmnxorgwmerge, \bpmnxorgwsplit \rightarrow \bpmnendevent, \bpmnstartevent \rightarrow \bpmnxorgwmerge, \bpmnxorgwmerge \rightarrow \anyofunique{\childrenof{\bpmnstartevent}}\} \cup \tilde{E}$ ;
		\item[---] $\Sigma_3 = \bigcup\limits_{v \in V_3} \{\sigma(v)\}$.
	\end{itemize}
	where 
	\begin{equation*}
		\tilde{V} = \
		\begin{cases}
			\emptyset & \text{if}\ \cardof{L} = 1	\\
			\{\bpmnpargwsplit, \bpmnpargwmerge\} & \text{otherwise} \\
		\end{cases} 
	\end{equation*}
	and
	\begin{equation*}
		\tilde{E} = \
		\begin{cases}
			\{\bpmnxorgwmerge \rightarrow L[0], L[0] \rightarrow \bpmnxorgwsplit\} & \text{if}\ \cardof{L} = 1	\\
			\{\bpmnxorgwmerge \rightarrow \bpmnpargwsplit, \bpmnpargwmerge \rightarrow \bpmnxorgwsplit\} \cup \bigcup\limits_{v \in L} \{\bpmnpargwsplit \rightarrow v, v \rightarrow \bpmnpargwmerge\} & \text{otherwise} \\
		\end{cases} 
	\end{equation*}
	
	\begin{comment}
		More formally, $G = (V', E', \Sigma')$ where:
		
		\begin{itemize}
			\item[---] $V' = V \cup L$ ;
			\item[---]   \begin{equation*}
				E' = E \cup \
				\begin{cases}
					(v_s, ..., v_n) & \text{if}\ v_s \in p	\\
					p & \text{otherwise} \\
				\end{cases} ;
			\end{equation*}
		\end{itemize}
	\end{comment}
	
	In case (ii), some $v \in L$ already belong to $G$, while some others do not.
	However, the loop nodes belonging to $G$ may be completely disconnected, already connected, or partially connected, thus no assumption can be made on how to connect them.
	If they do not form a strongly connected component yet, they have to be connected to make this strongly connected component appear in $G$.
	This starts by computing all the components of $\restrictionof{G}{L \cap V}$.
	
	\begin{comment}
		These graphs have the particularity of being \textit{directly connected}.
		
		\begin{definition}[Directly Connected Graph]
			Let $\graph$ be a graph.
			A graph $\widehat{G} = (\widehat{V} \subseteq V, \ \widehat{E} \subseteq \widehat{V} \times \widehat{V}, \ \widehat{\Sigma} \subseteq \Sigma)$ is said to be directly connected if and only if $\forall v_i \in \widehat{V}, \ \exists v_j \in \widehat{V}, \ v_i \neq v_j$, such that $\transition{v_i}{v_j} \in E \ \lor \ \transition{v_j}{v_i} \in E$.
			%By definition, $G$ is a directly connected graph.
		\end{definition}
		
		Then, the largest of them, called \textit{largest connected graphs}, are retrieved, as they represent the largest disconnected portions of the loop to insert.
		
		\begin{definition}[Largest Directly Connected Graph]
			Let $\graph$ be a graph and $S_{\widehat{G}} = \{\widehat{G}_1, ..., \widehat{G}_n\}$ be the set of all directly connected sub-graphs such that $V_{\widehat{G}_1} = V_{\widehat{G}_2} = ... = V_{\widehat{G}_n}$ and $E_{\widehat{G}_1} \neq E_{\widehat{G}_2} \neq ... \neq E_{\widehat{G}_n}$. The largest directly connected sub-graph of $S_{\widehat{G}}$ is the graph $\widehat{G}_L \in S_{\widehat{G}}$ such that $\lvert E_{\widehat{G}_L} \rvert = \max\limits_{i \in [1...n]} \lvert E_{\widehat{G}_i} \rvert$.
		\end{definition}
	\end{comment}
	
	These components represent disconnected portions of $L$ that one has to connect to make the strongly connected component corresponding to $L$ appear in $G$.
	However, this must be done carefully in order not to break any mutual exclusion already handled by $G$.
	Indeed, connecting two such components consists in adding new flows to $G$, which has an impact on its paths, and thus, potentially, on its mutual exclusions.
	To ensure that $L$ will be added to $G$ if it is possible (i.e., if it does not intrinsically break some mutual exclusions), all permutations of the components of $\restrictionof{G}{L \cap V}$ are computed.
	Each such permutation represents a possible order in which the components can be connected to the others to make the loop appear in $G$.
	For each such permutation, the $n^{\text{th}}$ component is connected to the ${n+1}^{\text{th}}$ component.
	This is done by connecting each node of the $n^{\text{th}}$ component having a \textit{0-reachability} to the set of nodes of the ${n+1}^{\text{th}}$ component ensuring an $\infty$\textit{-reachability}.
	
	\begin{definition}[$n$-reachability of a Node]
		Let $\graph$ be a BPMN process.
		$\forall v \in V$, the \textnormal{n-reachability} of $v$ is the number of nodes that $v$ can reach, i.e.,
		\begin{equation*}
			n = \cardof{\{v' \in V \setminus \{v\} \ \vert \ v \xrightarrow{R} v'\}}
		\end{equation*}
		By convention, if $n = \cardof{V} - 1$ (i.e., if $v$ can reach all the nodes of $G$), $v$ is said to have an $\infty$-reachability.
	\end{definition}
	
	This notion can be extended to a set of nodes.
	
	\begin{definition}[$n$-reachability of a Set of Nodes]
		Let $\graph$ be a BPMN process.
		$\forall \{v_1, ..., v_m\} \subseteq V$, the \textnormal{n-reachability} of $\{v_1, ..., v_m\}$ is the number of nodes that $\{v_1, ..., v_m\}$ can reach, i.e.,
		\begin{equation*}
			n = \cardof{\bigcup\limits_{v_i \in \{v_1, ..., v_m\}} \{v' \in V \setminus \{v_1, ..., v_m\} \ \vert \ v_i \xrightarrow{R} v'\}}
		\end{equation*}
		By convention, if $n = \cardof{V} - m$ (i.e., if the $\{v_1, ..., v_m\}$ can reach all the nodes of $G$), the set $\{v_1, ..., v_m\}$ is said to have an $\infty$-reachability.
	\end{definition}
	
	Such a connection ensures that each node of the $n^{\text{th}}$ component can now reach every node of the ${n+1}^{\text{th}}$ component, and also that the $n^{\text{th}}$ and ${n+1}^{\text{th}}$ components now form a single component.
	If during the connection phase, the $n^{\text{th}}$ component of a permutation cannot be connected to the ${n+1}^{\text{th}}$ component without breaking some existing mutual exclusions, the permutation is discarded.
	Once a valid permutation is found, the remaining ones are discarded.
	If no valid permutation is found, the explicit loop $L$ is not added to $G$.
	Finally, if some tasks of the loop did not already belong to $G$, they are arbitrarily added between two connected components, using the same method than in case (i).
	This step results in $G$ satisfying another set of constraints $\paramedconstraints{3}$.
	
	\begin{proposition}[Validity of the Components Connection]
		Let $\graph$ be a BPMN process, let $L = (v_1, ..., v_n) \in \loops$ be a loop that should be added to $G$, and let $\{G_1, ..., G_m\}$ be the set of components of $\restrictionof{G}{L \cap V}$.
		We state that $\forall i \in \closedarray{1}{m-1}$, connecting all the $\{v_1, ..., v_o\} \in G_i$ having a 0-reachability to the (smallest) set of $\{v_1, ..., v_p\} \in G_{i+1}$ ensuring an $\infty$-rechability, and all the $\{v_1, ..., v_q\} \in G_m$ having a 0-reachability to the (smallest) set of $\{v_1, ..., v_r\} \in G_{1}$ ensuring an $\infty$-rechability make $L$ become a strongly connected component in $G$.
	\end{proposition}
	
	\begin{proof}
		Let $\graph$ be a BPMN process, let $L = (v_1, ..., v_n) \in \loops$ be a loop that should be added to $G$, and let $\{G_1, ..., G_m\}$ be the set of components of $\restrictionof{G}{L \cap V}$.
		Let us separate the proof into two parts.
		
		First, let us show that connecting all the nodes of a component having a $0$-reachability to the (smallest) set of nodes having an $\infty$-reachability makes the component become a strongly connected component.
		Let $\{v_a, ..., v_m\}$ be the set of nodes of $G_1$ having a $0$-reachability, and let $\{v_n, ..., v_z\}$ be its (smallest) set of nodes ensuring an $\infty$-reachability.
		Adding an edge connecting each $v_i \in \{v_a, ..., v_m\}$ to each $v_j \in \{v_n, ..., v_z\}$ ensures that each $v_i \in \{v_a, ..., v_m\}$ now has a $\infty$-reachability.
		Moreover, by definition, each $v_k \notin \{v_a, ..., v_m\} \cup \{v_n, ..., v_z\}$ must have at least a 1-reachability (otherwise it would belong to the $\{v_a, ..., v_m\}$).
		Hence, it must be able to reach at least one $v_i \in \{v_a, ..., v_m\}$.
		However, we know that each $v_i \in \{v_a, ..., v_m\}$ now has an $\infty$-reachability.
		Thus, each $v_k \notin \{v_a, ..., v_m\} \cup \{v_n, ..., v_z\}$ now has an $\infty$-reachability.
		As each $v \in V$ now has a an $\infty$-reachability, $G$ is a strongly connected component.
		
		Then, let us show that connecting two components $G_1$ and $G_2$ with the same method creates another component $G_{1,2}$.
		Let $\{v_{1_a}, ..., v_{1_m}\}$ be the set of nodes of $G_1$ having a $0$-reachability, let $\{v_{1_n}, ..., v_{1_z}\}$ be its (smallest) set of nodes ensuring an $\infty$-reachability, let $\{v_{2_a}, ..., v_{2_m}\}$ be the set of nodes of $G_2$ having a $0$-reachability, and let $\{v_{2_n}, ..., v_{2_z}\}$ be its (smallest) set of nodes ensuring an $\infty$-reachability.
		Adding an edge connecting each $v_i \in \{v_{1_a}, ..., v_{1_m}\}$ to each $v_l \in \{v_{2_n}, ..., v_{2_z}\}$ ensures that $G_{1,2} = (V_1 \cup V_2, E_1 \cup E_2 \cup \{v_i \rightarrow v_l\ \vert\ v_i \in \{v_{1_a}, ..., v_{1_m}\}\ \land\ v_l \in \{v_{2_n}, ..., v_{2_z}\}\}, \Sigma_1 \cup \Sigma_2)$ is a component.
		Moreover, it also ensures that the $\{v_{1_n}, ..., v_{1_z}\}$ have an $\infty$-reachability on this component.
		By construction, we also have that the $\{v_{2_a}, ..., v_{2_m}\}$ still have a $0$-reachability.
		Thus, we created a component $G_{1,2}$ that contains both $G_1$ and $G_2$, and which has the same (smallest) set of $\infty$-reachability nodes than $G_1$, and the same set of $0$-reachability nodes than $G_2$.
		
		We showed that $\forall i \in \closedarray{1}{m-1}$, connecting each $G_i$ to each $G_{i+1}$ creates a component $G_f$ containing all the $G_i$, and whose (smallest) set of $\infty$-reachability nodes is the same than $G_1$, while its set of $0$-reachability nodes is the same than $G_m$.
		Finally, we showed that connecting this set of $0$-reachability nodes to the set of $\infty$-reachability nodes makes $G_f$ a strongly connected component, which is our goal.
	\end{proof}
\end{document}